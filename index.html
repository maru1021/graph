{% load static %}
{% load compress %}


<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>グラフツクール君2号</title>
    <script src="{% static 'js/vendor/chartjs/chart.min.js' %}"></script>
    <script src="{% static 'js/vendor/chartjs/chartjs-plugin-zoom.min.js' %}"></script>
    <script src="{% static 'js/vendor/xlsx/xlsx.full.min.js' %}"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #a8dadc 0%, #d4f1f4 100%);
            min-height: 100vh;
            padding: 15px;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 0 10px;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
            margin-bottom: 15px;
        }

        .header-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        h1 {
            color: #333;
            margin: 0;
            font-size: 24px;
        }

        .header-buttons {
            display: flex;
            gap: 10px;
        }

        .header-buttons input[type="file"] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: inline-block;
            padding: 12px 24px;
            background: linear-gradient(135deg, #4da8da 0%, #73c5e3 100%);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(77, 168, 218, 0.4);
        }

        .chart-container {
            position: relative;
            height: 600px;
            margin-top: 20px;
        }

        .chart-container canvas {
            position: relative;
            z-index: 1000;
        }

        /* Chart.jsのズームプラグインのドラッグ矩形を最前面に */
        .chartjs-zoom-drag-rect {
            z-index: 2000 !important;
        }

        .file-input-wrapper {
            position: relative;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            margin-bottom: 20px;
        }

        .controls-container {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px 15px;
            border: 2px solid #4da8da;
            border-radius: 8px;
            background: #f0f8ff;
        }

        .legend-threshold-wrapper {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .legend-checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .legend-label {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            cursor: pointer;
            white-space: nowrap;
        }

        .offset-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .offset-label-text {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            white-space: nowrap;
        }

        .file-list-container {
            display: flex;
            flex-direction: column;
            flex-wrap: wrap;
            gap: 10px;
            align-items: flex-start;
            max-height: 210px; /* 3行分の高さ (各アイテム約60px + gap 10px × 2) */
        }

        .file-item-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            width: 100px; /* 固定幅でinputの横位置を揃える */
        }

        .file-name {
            font-size: 12px;
            color: #333;
            font-weight: 500;
            white-space: nowrap;
            height: 16px; /* 固定の高さでinputの位置を揃える */
            line-height: 16px;
            width: 100px; /* 固定幅 */
            overflow: hidden;
            text-overflow: ellipsis;
            text-align: center;
        }

        .offset-input {
            width: 80px;
            padding: 6px 10px;
            border: 2px solid #4da8da;
            border-radius: 6px;
            font-size: 14px;
            text-align: center;
        }

        .offset-input:focus {
            outline: none;
            border-color: #2c8bb8;
        }

        .y-axis-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-start;
        }

        .y-axis-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .y-axis-label {
            font-size: 12px;
            font-weight: 500;
            min-width: 30px;
        }

        .y-axis-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .y-axis-checkbox-label {
            font-size: 12px;
            font-weight: 500;
            color: #333;
            cursor: pointer;
            white-space: nowrap;
        }

        .y-axis-select {
            padding: 4px 8px;
            border: 2px solid #4da8da;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            background-color: white;
            cursor: pointer;
        }

        .y-axis-select:focus {
            outline: none;
            border-color: #2c8bb8;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="header-wrapper">
                <h1>グラフツクール君2号</h1>
                <div class="header-buttons">
                    <input type="file" id="csvInput" multiple accept=".csv,.xlsx,.xls">
                    <label for="csvInput" class="file-input-label">
                        ファイルを選択（複数可）
                    </label>
                    <button id="resetZoomBtn" class="file-input-label" style="display: none;">
                        ズームリセット
                    </button>
                    <button id="exportCsvBtn" class="file-input-label" style="display: none;">
                        CSV出力
                    </button>
                </div>
            </div>
            <div class="file-input-wrapper">
                <div class="controls-container" style="display: none;" id="controlsContainer">
                    <div class="legend-threshold-wrapper">
                        <div class="legend-checkbox-wrapper">
                            <input type="checkbox" id="legendCheckbox" class="legend-checkbox">
                            <label for="legendCheckbox" class="legend-label">凡例</label>
                        </div>
                        <div id="thresholdSection" class="offset-section">
                            <span class="offset-label-text">閾値:</span>
                            <div style="display: flex; flex-direction: column; gap: 5px;">
                                <div style="display: flex; align-items: center; gap: 5px;">
                                    <span style="font-size: 12px; font-weight: 500; min-width: 40px;">上限:</span>
                                    <input type="number" id="upperThreshold" class="offset-input" placeholder="上限" style="width: 100px;">
                                </div>
                                <div style="display: flex; align-items: center; gap: 5px;">
                                    <span style="font-size: 12px; font-weight: 500; min-width: 40px;">下限:</span>
                                    <input type="number" id="lowerThreshold" class="offset-input" placeholder="下限" style="width: 100px;">
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="offsetSection" class="offset-section">
                        <span class="offset-label-text">オフセット:</span>
                        <div id="fileListContainer" class="file-list-container">
                            <!-- ファイルリストと位置補正入力欄がここに動的に追加されます -->
                        </div>
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <div class="offset-section">
                            <span class="offset-label-text" style="min-width: 100px; text-align: right;">X軸:</span>
                            <select id="xAxisSelect" class="y-axis-select" style="width: 120px;">
                                <option value="">なし</option>
                            </select>
                        </div>
                        <div class="offset-section">
                            <span class="offset-label-text" style="min-width: 100px; text-align: right;">グラフの種類:</span>
                            <select id="chartTypeSelect" class="y-axis-select" style="width: 120px;">
                                <option value="line">折れ線グラフ</option>
                                <option value="bar">棒グラフ</option>
                                <option value="scatter">散布図</option>
                            </select>
                        </div>
                    </div>
                    <div class="offset-section">
                        <span class="offset-label-text">除外:</span>
                        <div id="excludeContainer" style="display: flex; flex-wrap: wrap; gap: 5px; max-width: 300px; max-height: 80px; overflow-y: auto; border: 1px solid #ddd; padding: 5px; border-radius: 4px;">
                            <!-- チェックボックスがここに動的に追加されます -->
                        </div>
                    </div>
                    <div id="yAxisSection" class="offset-section">
                        <span class="offset-label-text">第2軸:</span>
                        <div class="y-axis-section">
                            <div class="y-axis-item">
                                <select id="yAxis1Select" class="y-axis-select">
                                    <option value="y2">第2軸</option>
                                    <option value="y3">第3軸</option>
                                    <option value="y4">第4軸</option>
                                </select>
                                <input type="checkbox" id="yAxis1Check" class="y-axis-checkbox">
                                <label for="yAxis1Check" class="y-axis-checkbox-label">含む</label>
                                <input type="text" id="yAxis1Input" class="offset-input" placeholder="列名の文字列" style="width: 120px; display: none;">
                                <select id="yAxis1ColumnSelect" class="y-axis-select" style="width: 120px;">
                                    <option value="">なし</option>
                                </select>
                                <select id="yAxis1TypeSelect" class="y-axis-select" style="width: 100px;">
                                    <option value="line">折れ線</option>
                                    <option value="bar">棒</option>
                                </select>
                            </div>
                            <div class="y-axis-item">
                                <select id="yAxis2Select" class="y-axis-select">
                                    <option value="y2">第2軸</option>
                                    <option value="y3">第3軸</option>
                                    <option value="y4">第4軸</option>
                                </select>
                                <input type="checkbox" id="yAxis2Check" class="y-axis-checkbox">
                                <label for="yAxis2Check" class="y-axis-checkbox-label">含む</label>
                                <input type="text" id="yAxis2Input" class="offset-input" placeholder="列名の文字列" style="width: 120px; display: none;">
                                <select id="yAxis2ColumnSelect" class="y-axis-select" style="width: 120px;">
                                    <option value="">なし</option>
                                </select>
                                <select id="yAxis2TypeSelect" class="y-axis-select" style="width: 100px;">
                                    <option value="line">折れ線</option>
                                    <option value="bar">棒</option>
                                </select>
                            </div>
                            <div class="y-axis-item">
                                <select id="yAxis3Select" class="y-axis-select">
                                    <option value="y2">第2軸</option>
                                    <option value="y3">第3軸</option>
                                    <option value="y4">第4軸</option>
                                </select>
                                <input type="checkbox" id="yAxis3Check" class="y-axis-checkbox">
                                <label for="yAxis3Check" class="y-axis-checkbox-label">含む</label>
                                <input type="text" id="yAxis3Input" class="offset-input" placeholder="列名の文字列" style="width: 120px; display: none;">
                                <select id="yAxis3ColumnSelect" class="y-axis-select" style="width: 120px;">
                                    <option value="">なし</option>
                                </select>
                                <select id="yAxis3TypeSelect" class="y-axis-select" style="width: 100px;">
                                    <option value="line">折れ線</option>
                                    <option value="bar">棒</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="chart-container">
                <canvas id="myChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        // 色系統ごとの配色（各系統に4色）- 隣接する色が最大限異なるように配置
        const colorFamilies = [
            // 赤系統
            ['rgb(220, 38, 38)', 'rgb(239, 68, 68)', 'rgb(185, 28, 28)', 'rgb(248, 113, 113)'],
            // シアン系統（赤の補色）
            ['rgb(8, 145, 178)', 'rgb(6, 182, 212)', 'rgb(14, 116, 144)', 'rgb(34, 211, 238)'],
            // オレンジ系統
            ['rgb(234, 88, 12)', 'rgb(249, 115, 22)', 'rgb(194, 65, 12)', 'rgb(251, 146, 60)'],
            // 青系統（オレンジの補色）
            ['rgb(37, 99, 235)', 'rgb(59, 130, 246)', 'rgb(29, 78, 216)', 'rgb(96, 165, 250)'],
            // 緑系統
            ['rgb(22, 163, 74)', 'rgb(34, 197, 94)', 'rgb(21, 128, 61)', 'rgb(74, 222, 128)'],
            // 紫系統
            ['rgb(147, 51, 234)', 'rgb(168, 85, 247)', 'rgb(126, 34, 206)', 'rgb(192, 132, 252)'],
            // 黄色系統
            ['rgb(234, 179, 8)', 'rgb(250, 204, 21)', 'rgb(202, 138, 4)', 'rgb(253, 224, 71)'],
            // マゼンタ/ピンク系統
            ['rgb(219, 39, 119)', 'rgb(236, 72, 153)', 'rgb(190, 24, 93)', 'rgb(244, 114, 182)']
        ];

        let chart = null;
        let uploadedFiles = [];
        let fileOffsets = new Map(); // ファイル名 -> オフセット値
        let preserveZoom = false; // ズーム状態を保持するかどうかのフラグ
        let savedZoomState = null; // 保存されたズーム状態
        let upperThresholdValue = null; // 上限閾値
        let lowerThresholdValue = null; // 下限閾値
        let blinkTimer = null; // 点滅タイマー
        let blinkState = true; // 点滅状態
        let datasetVisibility = new Map(); // データセットのラベル -> 表示状態のマップ
        let tooltipEnabled = false; // ツールチップの有効/無効状態（デフォルト: 非表示）
        let xAxisPattern = ''; // X軸として使用する列名のパターン
        let excludedColumns = []; // 除外する列名のリスト
        let excludedFiles = []; // 除外するファイル名のリスト
        let chartType = 'line'; // グラフの種類（デフォルト: 折れ線グラフ）

        // 第2軸設定
        let yAxisConfigs = [
            { enabled: false, pattern: '', axis: 'y2', chartType: 'line' },  // 設定1（デフォルト: 第2軸、折れ線）
            { enabled: false, pattern: '', axis: 'y2', chartType: 'line' },  // 設定2（デフォルト: 第2軸、折れ線）
            { enabled: false, pattern: '', axis: 'y2', chartType: 'line' }   // 設定3（デフォルト: 第2軸、折れ線）
        ];

        const csvInput = document.getElementById('csvInput');
        const resetZoomBtn = document.getElementById('resetZoomBtn');
        const exportCsvBtn = document.getElementById('exportCsvBtn');
        const fileListContainer = document.getElementById('fileListContainer');
        const controlsContainer = document.getElementById('controlsContainer');
        const legendCheckbox = document.getElementById('legendCheckbox');
        const xAxisSelect = document.getElementById('xAxisSelect');
        const chartTypeSelect = document.getElementById('chartTypeSelect');
        const excludeContainer = document.getElementById('excludeContainer');
        const upperThresholdInput = document.getElementById('upperThreshold');
        const lowerThresholdInput = document.getElementById('lowerThreshold');

        // 第2軸入力要素（配列化）
        const yAxisElements = [
            {
                select: document.getElementById('yAxis1Select'),
                check: document.getElementById('yAxis1Check'),
                input: document.getElementById('yAxis1Input'),
                columnSelect: document.getElementById('yAxis1ColumnSelect'),
                typeSelect: document.getElementById('yAxis1TypeSelect')
            },
            {
                select: document.getElementById('yAxis2Select'),
                check: document.getElementById('yAxis2Check'),
                input: document.getElementById('yAxis2Input'),
                columnSelect: document.getElementById('yAxis2ColumnSelect'),
                typeSelect: document.getElementById('yAxis2TypeSelect')
            },
            {
                select: document.getElementById('yAxis3Select'),
                check: document.getElementById('yAxis3Check'),
                input: document.getElementById('yAxis3Input'),
                columnSelect: document.getElementById('yAxis3ColumnSelect'),
                typeSelect: document.getElementById('yAxis3TypeSelect')
            }
        ];

        resetZoomBtn.addEventListener('click', () => {
            if (chart) {
                chart.resetZoom();
                savedZoomState = null; // ズーム状態をクリア
                preserveZoom = false; // リセット後は保存しない
            }
        });

        // 凡例チェックボックスのイベントリスナー
        legendCheckbox.addEventListener('change', async (e) => {
            tooltipEnabled = e.target.checked; // チェックON = ツールチップON
            if (chart) {
                preserveZoom = true;
                await renderChartFromFiles();
            }
        });

        // X軸設定のイベントリスナー
        xAxisSelect.addEventListener('change', async (e) => {
            xAxisPattern = e.target.value;
            if (chart) {
                preserveZoom = true;
                await renderChartFromFiles();
            }
        });

        // グラフの種類選択のイベントリスナー
        chartTypeSelect.addEventListener('change', async (e) => {
            chartType = e.target.value;
            if (chart) {
                preserveZoom = true;
                await renderChartFromFiles();
            }
        });

        exportCsvBtn.addEventListener('click', () => {
            if (chart) {
                exportChartDataToCsv();
            }
        });

        // 閾値の入力イベント（統合）
        const thresholdInputs = [
            { input: upperThresholdInput, setValue: (val) => upperThresholdValue = val },
            { input: lowerThresholdInput, setValue: (val) => lowerThresholdValue = val }
        ];

        thresholdInputs.forEach(({ input, setValue }) => {
            input.addEventListener('input', async (e) => {
                const value = e.target.value;
                setValue(value === '' ? null : parseFloat(value));
                if (chart) {
                    preserveZoom = true;
                    await renderChartFromFiles();
                }
            });
        });

        // 第2軸設定のイベントリスナー（ループ化）
        yAxisElements.forEach((elements, index) => {
            // 軸選択のイベントリスナー
            elements.select.addEventListener('change', async (e) => {
                yAxisConfigs[index].axis = e.target.value;
                // 列が選択されている場合は再描画（enabledに関わらず）
                if (chart && yAxisConfigs[index].pattern) {
                    preserveZoom = true;
                    await renderChartFromFiles();
                }
            });

            // 「含む」チェックボックスのイベントリスナー
            elements.check.addEventListener('change', async (e) => {
                yAxisConfigs[index].enabled = e.target.checked;
                // チェック状態に応じて表示を切り替え
                if (e.target.checked) {
                    elements.input.style.display = '';
                    elements.columnSelect.style.display = 'none';
                } else {
                    elements.input.style.display = 'none';
                    elements.columnSelect.style.display = '';
                    // selectの値をpatternに反映
                    yAxisConfigs[index].pattern = elements.columnSelect.value;
                }
                if (chart) {
                    preserveZoom = true;
                    await renderChartFromFiles();
                }
            });

            // テキスト入力のイベントリスナー
            elements.input.addEventListener('input', async (e) => {
                yAxisConfigs[index].pattern = e.target.value.trim();
                if (chart && elements.check.checked) {
                    preserveZoom = true;
                    await renderChartFromFiles();
                }
            });

            // 列名selectのイベントリスナー
            elements.columnSelect.addEventListener('change', async (e) => {
                yAxisConfigs[index].pattern = e.target.value;
                if (chart) {
                    preserveZoom = true;
                    await renderChartFromFiles();
                }
            });

            // グラフの種類selectのイベントリスナー
            elements.typeSelect.addEventListener('change', async (e) => {
                yAxisConfigs[index].chartType = e.target.value;
                if (chart) {
                    preserveZoom = true;
                    await renderChartFromFiles();
                }
            });
        });

        csvInput.addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);

            if (files.length === 0) return;

            uploadedFiles = files;

            // ファイルごとのオフセットを初期化
            fileOffsets.clear();
            files.forEach(file => fileOffsets.set(file.name, 0));

            // ファイルリストを表示
            displayFileList(files);

            // 新しいファイルアップロード時はズームと表示状態をリセット
            preserveZoom = false;
            savedZoomState = null;
            datasetVisibility.clear();

            // グラフを描画
            await renderChartFromFiles();
        });

        // ファイルリストを表示する関数
        function displayFileList(files) {
            fileListContainer.innerHTML = '';

            files.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item-control';

                const fileName = document.createElement('span');
                fileName.className = 'file-name';
                fileName.textContent = file.name;

                const offsetInput = document.createElement('input');
                offsetInput.type = 'number';
                offsetInput.className = 'offset-input';
                offsetInput.value = '0';
                offsetInput.step = '1';
                offsetInput.placeholder = '位置補正';
                offsetInput.dataset.fileName = file.name;

                offsetInput.addEventListener('input', async (e) => {
                    const offset = parseInt(e.target.value) || 0;
                    fileOffsets.set(file.name, offset);
                    preserveZoom = true; // オフセット変更時もズームと表示状態を保持
                    await renderChartFromFiles();
                });

                fileItem.appendChild(fileName);
                fileItem.appendChild(offsetInput);

                fileListContainer.appendChild(fileItem);
            });

            // コントロールコンテナを表示
            controlsContainer.style.display = 'flex';
        }

        // ファイルからグラフを描画する関数
        async function renderChartFromFiles() {
            const parsedData = [];
            let minIndex = 0;
            let maxIndex = 0;

            // すべてのファイルを解析してインデックス範囲を計算
            for (let i = 0; i < uploadedFiles.length; i++) {
                const file = uploadedFiles[i];
                try {
                    const offset = fileOffsets.get(file.name) || 0;

                    // ファイル拡張子で判別
                    const fileName = file.name.toLowerCase();
                    if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
                        // Excelファイル（全シート対応、配列を返す）
                        const cleanName = file.name.replace(/\.(xlsx|xls)$/i, '');
                        const results = await parseExcel(file, cleanName, offset);

                        // 各シートのデータを追加
                        for (const result of results) {
                            parsedData.push(result);
                            // インデックスの範囲を更新
                            if (result.minIndex < minIndex) minIndex = result.minIndex;
                            if (result.maxIndex > maxIndex) maxIndex = result.maxIndex;
                        }
                    } else {
                        // CSVファイル
                        const text = await file.text();
                        const cleanName = file.name.replace('.csv', '');
                        const result = parseCSV(text, cleanName, offset);

                        parsedData.push(result);
                        // インデックスの範囲を更新
                        if (result.minIndex < minIndex) minIndex = result.minIndex;
                        if (result.maxIndex > maxIndex) maxIndex = result.maxIndex;
                    }
                } catch (error) {
                    console.error(`Error parsing ${file.name}:`, error);
                    alert(`${file.name}の読み込みに失敗しました: ${error.message}`);
                }
            }

            // X軸selectと第2軸selectの選択肢を更新
            const columnNames = new Set();
            // ファイル名とその元のファイル名を対応させるマップ（シート名対応版）
            const fileDataToOriginalName = new Map();
            uploadedFiles.forEach(file => {
                const cleanName = file.name.replace(/\.(csv|xlsx|xls)$/i, '');
                fileDataToOriginalName.set(cleanName, file.name);
            });
            // parsedDataからシート名付きのファイル名もマッピング（"ファイル名_シート名" -> "ファイル名.xlsx"）
            parsedData.forEach(fileData => {
                const originalFile = uploadedFiles.find(f => {
                    const cleanName = f.name.replace(/\.(csv|xlsx|xls)$/i, '');
                    return fileData.fileName === cleanName || fileData.fileName.startsWith(cleanName + '_');
                });
                if (originalFile) {
                    fileDataToOriginalName.set(fileData.fileName, originalFile.name);
                }
            });

            parsedData.forEach(fileData => {
                // 除外されたファイルをスキップ
                const originalFileName = fileDataToOriginalName.get(fileData.fileName) || fileData.fileName;
                if (excludedFiles.includes(originalFileName)) {
                    return;
                }

                fileData.datasets.forEach(dataset => {
                    const columnName = dataset.label.split(' - ')[1];
                    if (columnName) {
                        columnNames.add(columnName);
                    }
                });
            });

            // 現在の選択値を保存
            const currentXAxisValue = xAxisSelect.value;
            const currentYAxisValues = yAxisElements.map(el => el.columnSelect.value);

            // X軸selectをクリアして再構築
            xAxisSelect.innerHTML = '<option value="">なし</option>';
            Array.from(columnNames).sort().forEach(columnName => {
                const option = document.createElement('option');
                option.value = columnName;
                option.textContent = columnName;
                xAxisSelect.appendChild(option);
            });

            // 前の選択値を復元（存在する場合）
            if (currentXAxisValue && columnNames.has(currentXAxisValue)) {
                xAxisSelect.value = currentXAxisValue;
            }

            // 第2軸のcolumn selectをクリアして再構築（ループ化）
            yAxisElements.forEach((elements, index) => {
                elements.columnSelect.innerHTML = '<option value="">なし</option>';
                Array.from(columnNames).sort().forEach(columnName => {
                    const option = document.createElement('option');
                    option.value = columnName;
                    option.textContent = columnName;
                    elements.columnSelect.appendChild(option);
                });

                // 前の選択値を復元（存在する場合）
                if (currentYAxisValues[index] && columnNames.has(currentYAxisValues[index])) {
                    elements.columnSelect.value = currentYAxisValues[index];
                }
            });

            // 全ての列名に対して色系統インデックスを割り当て（常に固定）
            const columnNameToColorFamily = new Map();
            let nextColorFamily = 0;
            Array.from(columnNames).sort().forEach(columnName => {
                columnNameToColorFamily.set(columnName, nextColorFamily % colorFamilies.length);
                nextColorFamily++;
            });

            // 除外チェックボックスを更新
            const currentExcludedValues = excludedColumns.slice();
            const currentExcludedFiles = excludedFiles.slice();

            // コンテナをクリアして再構築
            excludeContainer.innerHTML = '';

            // 列名のチェックボックスを追加
            Array.from(columnNames).sort().forEach(columnName => {
                const label = document.createElement('label');
                label.style.display = 'flex';
                label.style.alignItems = 'center';
                label.style.gap = '3px';
                label.style.cursor = 'pointer';
                label.style.whiteSpace = 'nowrap';
                label.style.padding = '2px 6px';
                label.style.borderRadius = '4px';

                // 列名に対応する色系統の代表色（最初の色）を取得
                const colorFamilyIndex = columnNameToColorFamily.get(columnName) || 0;
                const representativeColor = colorFamilies[colorFamilyIndex][0];
                // RGBを半透明のRGBAに変換
                const bgColor = representativeColor.replace('rgb', 'rgba').replace(')', ', 0.3)');
                label.style.backgroundColor = bgColor;

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = columnName;
                checkbox.checked = currentExcludedValues.includes(columnName);

                checkbox.addEventListener('change', async (e) => {
                    if (e.target.checked) {
                        if (!excludedColumns.includes(columnName)) {
                            excludedColumns.push(columnName);
                        }
                    } else {
                        const index = excludedColumns.indexOf(columnName);
                        if (index > -1) {
                            excludedColumns.splice(index, 1);
                        }
                    }
                    if (chart) {
                        preserveZoom = true;
                        await renderChartFromFiles();
                    }
                });

                const span = document.createElement('span');
                span.textContent = columnName;
                span.style.fontSize = '12px';
                span.style.fontWeight = '500';

                label.appendChild(checkbox);
                label.appendChild(span);
                excludeContainer.appendChild(label);
            });

            // ファイル/シート名のチェックボックスを追加（重複排除）
            const addedFileNames = new Set();
            parsedData.forEach(fileData => {
                const originalFileName = fileDataToOriginalName.get(fileData.fileName) || fileData.fileName;

                // 既に追加済みの場合はスキップ（重複防止）
                if (addedFileNames.has(originalFileName)) {
                    return;
                }
                addedFileNames.add(originalFileName);

                const label = document.createElement('label');
                label.style.display = 'flex';
                label.style.alignItems = 'center';
                label.style.gap = '3px';
                label.style.cursor = 'pointer';
                label.style.whiteSpace = 'nowrap';
                label.style.padding = '2px 6px';
                label.style.borderRadius = '4px';
                label.style.backgroundColor = 'rgba(128, 128, 128, 0.3)'; // グレー系の背景

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = originalFileName;
                checkbox.checked = currentExcludedFiles.includes(originalFileName);

                checkbox.addEventListener('change', async (e) => {
                    if (e.target.checked) {
                        if (!excludedFiles.includes(originalFileName)) {
                            excludedFiles.push(originalFileName);
                        }
                    } else {
                        const index = excludedFiles.indexOf(originalFileName);
                        if (index > -1) {
                            excludedFiles.splice(index, 1);
                        }
                    }
                    if (chart) {
                        preserveZoom = true;
                        await renderChartFromFiles();
                    }
                });

                const span = document.createElement('span');
                span.textContent = originalFileName;
                span.style.fontSize = '12px';
                span.style.fontWeight = '500';

                label.appendChild(checkbox);
                label.appendChild(span);
                excludeContainer.appendChild(label);
            });

            // データセットを再構築
            const datasets = [];
            const thresholdViolations = []; // 閾値違反のデータを保存

            // ファイル名（シート名含む）ごとにインデックスを取得するマップ
            const fileNameToIndex = new Map();
            let colorIndex = 0;
            parsedData.forEach((fileData) => {
                fileNameToIndex.set(fileData.fileName, colorIndex);
                colorIndex++;
            });

            parsedData.forEach(fileData => {
                // 除外されたファイルをスキップ
                const originalFileName = fileDataToOriginalName.get(fileData.fileName) || fileData.fileName;
                if (excludedFiles.includes(originalFileName)) {
                    return;
                }

                // X軸データを探す
                let xAxisData = null;
                const fileOffset = fileOffsets.get(originalFileName) || 0; // ファイルのオフセットを取得

                if (xAxisPattern) {
                    const xAxisDataset = fileData.datasets.find(dataset => {
                        const columnName = dataset.label.split(' - ')[1] || '';
                        return columnName === xAxisPattern;
                    });
                    if (xAxisDataset) {
                        // X軸データのマップを作成（行インデックス -> X値+オフセット）
                        xAxisData = new Map();
                        xAxisDataset.data.forEach(point => {
                            // X軸の値にもオフセットを加算
                            xAxisData.set(point.x, point.y + fileOffset);
                        });
                    }
                }

                fileData.datasets.forEach(dataset => {
                    const columnName = dataset.label.split(' - ')[1] || '';

                    // X軸として使用する列はスキップ
                    if (xAxisPattern && columnName === xAxisPattern) {
                        return;
                    }

                    // 除外された列はスキップ
                    if (excludedColumns.includes(columnName)) {
                        return;
                    }

                    let numericData;
                    if (xAxisData) {
                        // X軸データがある場合、それを使用（既にオフセット適用済み）
                        numericData = dataset.data.map(point => ({
                            x: xAxisData.get(point.x) || parseInt(point.x),
                            y: point.y
                        }));
                    } else {
                        // X軸データがない場合、従来通りインデックスを使用
                        numericData = dataset.data.map(point => ({
                            x: parseInt(point.x),
                            y: point.y
                        }));
                    }

                    // 第2軸の判定
                    const yAxisID = getYAxisID(dataset.label, fileData.fileName);

                    // グラフの種類の判定
                    const datasetChartType = getChartType(dataset.label, fileData.fileName);

                    // 色を決定：列名から色系統を取得し、ファイルインデックスから系統内の色を選択
                    const colorFamilyIndex = columnNameToColorFamily.get(columnName) || 0;
                    const fileIndex = fileNameToIndex.get(fileData.fileName) || 0;
                    const colorFamily = colorFamilies[colorFamilyIndex];
                    const color = colorFamily[fileIndex % colorFamily.length];

                    // グラフの種類に応じた設定
                    const datasetConfig = {
                        type: datasetChartType, // データセット個別のグラフの種類
                        label: dataset.label,
                        data: numericData,
                        borderColor: color,
                        backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.1)'),
                        tension: 0,
                        borderWidth: 2,
                        fill: false,
                        spanGaps: true,
                        yAxisID: yAxisID
                    };

                    // 散布図の場合は点を表示、それ以外は線のみ
                    if (datasetChartType === 'scatter') {
                        datasetConfig.pointRadius = 4;
                        datasetConfig.pointHoverRadius = 4;
                        datasetConfig.pointBackgroundColor = color;
                        datasetConfig.pointBorderColor = color;
                        datasetConfig.pointHoverBackgroundColor = color;
                        datasetConfig.pointHoverBorderColor = color;
                        datasetConfig.showLine = false;
                    } else {
                        datasetConfig.pointRadius = 0;
                        datasetConfig.pointHoverRadius = 0;
                    }

                    datasets.push(datasetConfig);

                    // 閾値を超えた部分を検出
                    if (upperThresholdValue !== null || lowerThresholdValue !== null) {
                        const violationData = numericData.filter(point => {
                            const exceedsUpper = upperThresholdValue !== null && point.y > upperThresholdValue;
                            const exceedsLower = lowerThresholdValue !== null && point.y < lowerThresholdValue;
                            return exceedsUpper || exceedsLower;
                        });

                        // 違反データがあれば保存（線として表示）
                        if (violationData.length > 0) {
                            thresholdViolations.push({
                                label: dataset.label + ' (閾値超過)',
                                data: violationData,
                                originalColor: color,
                                yAxisID: yAxisID,
                                chartType: datasetChartType
                            });
                        }
                    }
                });
            });

            // 閾値の線を追加（ループ化）
            const thresholds = [
                { value: upperThresholdValue, label: '上限閾値' },
                { value: lowerThresholdValue, label: '下限閾値' }
            ];

            thresholds.forEach(({ value, label }) => {
                if (value !== null) {
                    datasets.push({
                        type: 'line', // 常に折れ線グラフ
                        label: label,
                        data: [
                            { x: minIndex, y: value },
                            { x: maxIndex, y: value }
                        ],
                        borderColor: 'rgb(255, 0, 0)',
                        backgroundColor: 'rgba(255, 0, 0, 0.1)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        fill: false,
                        tension: 0,
                        yAxisID: 'y'
                    });
                }
            });

            // 閾値違反の線を追加（点滅用）
            thresholdViolations.forEach(violation => {
                const violationConfig = {
                    type: violation.chartType, // データセット個別のグラフの種類
                    label: violation.label,
                    data: violation.data,
                    borderColor: 'rgb(255, 0, 0)',
                    backgroundColor: 'rgba(255, 0, 0, 0.1)',
                    tension: 0,
                    borderWidth: 3,
                    fill: false,
                    spanGaps: false, // 閾値を超えていない部分は線を引かない
                    isViolation: true, // 点滅対象のマーク
                    yAxisID: violation.yAxisID
                };

                // 散布図の場合は点を表示
                if (violation.chartType === 'scatter') {
                    violationConfig.pointRadius = 6;
                    violationConfig.pointHoverRadius = 6;
                    violationConfig.pointBackgroundColor = 'rgb(255, 0, 0)';
                    violationConfig.pointBorderColor = 'rgb(255, 0, 0)';
                    violationConfig.pointHoverBackgroundColor = 'rgb(255, 0, 0)';
                    violationConfig.pointHoverBorderColor = 'rgb(255, 0, 0)';
                    violationConfig.showLine = false;
                } else {
                    violationConfig.pointRadius = 0;
                    violationConfig.pointHoverRadius = 0;
                }

                datasets.push(violationConfig);
            });

            if (datasets.length > 0) {
                renderChart(datasets);
            }
        }

        function parseCSV(text, fileName, offset = 0) {
            const lines = text.trim().split('\n');
            if (lines.length < 2) {
                throw new Error('CSVファイルが空か、データが不足しています');
            }

            // ヘッダー行を解析
            const headers = lines[0].split(',').map(h => h.trim());
            const columnCount = headers.length;

            if (columnCount < 1) {
                throw new Error('CSVファイルには少なくとも1列が必要です');
            }

            // 各列のデータを格納する配列を初期化（すべての列をデータとして使用）
            const datasets = [];
            for (let col = 0; col < columnCount; col++) {
                datasets.push({
                    label: `${fileName} - ${headers[col]}`,
                    data: []
                });
            }

            // データの範囲を計算
            const dataRowCount = lines.length - 1; // ヘッダーを除く
            const minIndex = offset;
            const maxIndex = offset + dataRowCount - 1;

            // データ行を解析
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const values = line.split(',');
                if (values.length >= 1) {
                    // データ行のインデックス（0始まり）にオフセットを加える
                    const dataIndex = i - 1; // 0始まりのデータ行インデックス
                    const xValue = (dataIndex + offset).toString();

                    // すべての列を処理
                    for (let col = 0; col < Math.min(values.length, columnCount); col++) {
                        const yValue = parseFloat(values[col].trim());
                        if (!isNaN(yValue)) {
                            datasets[col].data.push({ x: xValue, y: yValue });
                        }
                    }
                }
            }

            return { datasets, minIndex, maxIndex, fileName };
        }

        // Excelファイルを解析する関数（全シート対応）
        async function parseExcel(file, fileName, offset = 0) {
            const arrayBuffer = await file.arrayBuffer();
            const workbook = XLSX.read(arrayBuffer, { type: 'array' });

            const results = []; // 全シートのデータを格納

            // 全シートをループ処理
            for (let sheetIndex = 0; sheetIndex < workbook.SheetNames.length; sheetIndex++) {
                const sheetName = workbook.SheetNames[sheetIndex];
                const worksheet = workbook.Sheets[sheetName];

                // シートをJSONに変換（ヘッダー行を含む）
                const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                // 空のシートや不十分なデータはスキップ
                if (!jsonData || jsonData.length < 2) {
                    continue;
                }

                // ヘッダー行を取得
                const headers = jsonData[0].map(h => h ? h.toString().trim() : '');
                const columnCount = headers.length;

                if (columnCount < 1) {
                    continue;
                }

                // シート名をファイル名に含める（複数シートの場合のみ）
                const sheetFileName = workbook.SheetNames.length > 1
                    ? `${fileName}_${sheetName}`
                    : fileName;

                // 各列のデータを格納する配列を初期化
                const datasets = [];
                for (let col = 0; col < columnCount; col++) {
                    datasets.push({
                        label: `${sheetFileName} - ${headers[col]}`,
                        data: []
                    });
                }

                // データの範囲を計算
                const dataRowCount = jsonData.length - 1; // ヘッダーを除く
                const minIndex = offset;
                const maxIndex = offset + dataRowCount - 1;

                // データ行を解析
                for (let i = 1; i < jsonData.length; i++) {
                    const row = jsonData[i];
                    if (!row || row.length === 0) continue;

                    // データ行のインデックス（0始まり）にオフセットを加える
                    const dataIndex = i - 1; // 0始まりのデータ行インデックス
                    const xValue = (dataIndex + offset).toString();

                    // すべての列を処理
                    for (let col = 0; col < Math.min(row.length, columnCount); col++) {
                        const yValue = parseFloat(row[col]);
                        if (!isNaN(yValue)) {
                            datasets[col].data.push({ x: xValue, y: yValue });
                        }
                    }
                }

                results.push({ datasets, minIndex, maxIndex, fileName: sheetFileName });
            }

            // シートが1つもない場合はエラー
            if (results.length === 0) {
                throw new Error('Excelファイルに有効なデータシートがありません');
            }

            return results; // 配列を返す
        }

        // 第2軸IDを取得する関数
        function getYAxisID(label, fileName) {
            // ラベルから列名を抽出 ("fileName - columnName" から列名部分)
            const columnName = label.split(' - ')[1] || '';

            // 各設定をチェック
            for (let i = 0; i < yAxisConfigs.length; i++) {
                const config = yAxisConfigs[i];
                // パターンが入力されている場合のみ
                if (config.pattern && config.pattern.trim() !== '') {
                    let isMatch = false;
                    if (config.enabled) {
                        // チェックON: 部分一致（含む）
                        isMatch = columnName.includes(config.pattern.trim());
                    } else {
                        // チェックOFF: 完全一致
                        isMatch = columnName === config.pattern.trim();
                    }

                    if (isMatch) {
                        return config.axis; // 選択された軸（y2, y3, y4）を返す
                    }
                }
            }
            return 'y'; // デフォルトは第1軸
        }

        // グラフの種類を取得する関数
        function getChartType(label, fileName) {
            // ラベルから列名を抽出
            const columnName = label.split(' - ')[1] || '';

            // 各設定をチェック
            for (let i = 0; i < yAxisConfigs.length; i++) {
                const config = yAxisConfigs[i];
                // パターンが入力されている場合のみ
                if (config.pattern && config.pattern.trim() !== '') {
                    let isMatch = false;
                    if (config.enabled) {
                        // チェックON: 部分一致（含む）
                        isMatch = columnName.includes(config.pattern.trim());
                    } else {
                        // チェックOFF: 完全一致
                        isMatch = columnName === config.pattern.trim();
                    }

                    if (isMatch) {
                        return config.chartType; // 設定されたグラフの種類を返す
                    }
                }
            }
            return chartType; // デフォルトは全体のグラフの種類
        }

        function renderChart(datasets) {
            const ctx = document.getElementById('myChart').getContext('2d');

            // 既存のグラフから各データセットの表示・非表示状態を保存
            if (chart && preserveZoom) {
                chart.data.datasets.forEach((dataset, index) => {
                    const meta = chart.getDatasetMeta(index);
                    datasetVisibility.set(dataset.label, !meta.hidden);
                });
            }

            // データの範囲を計算（limitsの設定用、軸ごとに分ける）
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minY2 = Infinity, maxY2 = -Infinity;
            let minY3 = Infinity, maxY3 = -Infinity;
            let minY4 = Infinity, maxY4 = -Infinity;

            datasets.forEach(dataset => {
                dataset.data.forEach(point => {
                    if (point.x < minX) minX = point.x;
                    if (point.x > maxX) maxX = point.x;

                    // 軸ごとにy値の範囲を計算
                    if (dataset.yAxisID === 'y') {
                        if (point.y < minY) minY = point.y;
                        if (point.y > maxY) maxY = point.y;
                    } else if (dataset.yAxisID === 'y2') {
                        if (point.y < minY2) minY2 = point.y;
                        if (point.y > maxY2) maxY2 = point.y;
                    } else if (dataset.yAxisID === 'y3') {
                        if (point.y < minY3) minY3 = point.y;
                        if (point.y > maxY3) maxY3 = point.y;
                    } else if (dataset.yAxisID === 'y4') {
                        if (point.y < minY4) minY4 = point.y;
                        if (point.y > maxY4) maxY4 = point.y;
                    }
                });
            });

            if (chart) {
                chart.destroy();
            }

            // 使用されている軸を判定
            const usedAxes = new Set();
            datasets.forEach(dataset => {
                if (dataset.yAxisID) {
                    usedAxes.add(dataset.yAxisID);
                }
            });

            chart = new Chart(ctx, {
                type: chartType,
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    resizeDelay: 200, // リサイズ時の更新遅延（ミリ秒）
                    animation: false, // アニメーション完全無効化
                    plugins: {
                        decimation: {
                            enabled: true,
                            algorithm: 'lttb', // Largest-Triangle-Three-Buckets アルゴリズム
                            samples: 400 // 表示時の最大サンプル数（軽量化）
                        },
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 12,
                                font: {
                                    size: 12
                                }
                            },
                            onClick: function(e, legendItem, legend) {
                                // デフォルトの動作を実行（データセットの表示/非表示を切り替え）
                                const index = legendItem.datasetIndex;
                                const ci = legend.chart;

                                if (ci.isDatasetVisible(index)) {
                                    ci.hide(index);
                                    legendItem.hidden = true;
                                } else {
                                    ci.show(index);
                                    legendItem.hidden = false;
                                }

                                // 表示/非表示切り替え後のズーム状態を保存
                                setTimeout(() => {
                                    // Chart.jsがスケールを再計算した後に実行
                                    if (ci.scales && ci.scales.x && ci.scales.y) {
                                        savedZoomState = {
                                            x: {
                                                min: ci.scales.x.min,
                                                max: ci.scales.x.max
                                            },
                                            y: {
                                                min: ci.scales.y.min,
                                                max: ci.scales.y.max
                                            },
                                            y2: ci.scales.y2 ? {
                                                min: ci.scales.y2.min,
                                                max: ci.scales.y2.max
                                            } : undefined,
                                            y3: ci.scales.y3 ? {
                                                min: ci.scales.y3.min,
                                                max: ci.scales.y3.max
                                            } : undefined,
                                            y4: ci.scales.y4 ? {
                                                min: ci.scales.y4.min,
                                                max: ci.scales.y4.max
                                            } : undefined
                                        };
                                        preserveZoom = true;
                                    }
                                }, 50);
                            }
                        },
                        tooltip: {
                            enabled: tooltipEnabled,
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            titleFont: {
                                size: 14
                            },
                            bodyFont: {
                                size: 13
                            },
                            callbacks: {
                                title: function() {
                                    return '';  // タイトル（行番号）を非表示
                                }
                            }
                        },
                        zoom: {
                            zoom: {
                                wheel: {
                                    enabled: true,
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: 'rgba(102, 126, 234, 0.3)',
                                    borderColor: 'rgba(102, 126, 234, 1)',
                                    borderWidth: 2,
                                    threshold: 50,
                                    drawTime: 'afterDatasetsDraw'
                                },
                                mode: 'xy',
                                onZoomComplete: function({chart}) {
                                    // ズーム完了後に状態を保存
                                    savedZoomState = {
                                        x: {
                                            min: chart.scales.x.min,
                                            max: chart.scales.x.max
                                        },
                                        y: {
                                            min: chart.scales.y.min,
                                            max: chart.scales.y.max
                                        },
                                        y2: chart.scales.y2 ? {
                                            min: chart.scales.y2.min,
                                            max: chart.scales.y2.max
                                        } : undefined,
                                        y3: chart.scales.y3 ? {
                                            min: chart.scales.y3.min,
                                            max: chart.scales.y3.max
                                        } : undefined,
                                        y4: chart.scales.y4 ? {
                                            min: chart.scales.y4.min,
                                            max: chart.scales.y4.max
                                        } : undefined
                                    };
                                    preserveZoom = true;
                                }
                            },
                            pan: {
                                enabled: true,
                                mode: 'xy',
                                modifierKey: 'shift',
                                onPanComplete: function({chart}) {
                                    // パン完了後に状態を保存
                                    savedZoomState = {
                                        x: {
                                            min: chart.scales.x.min,
                                            max: chart.scales.x.max
                                        },
                                        y: {
                                            min: chart.scales.y.min,
                                            max: chart.scales.y.max
                                        },
                                        y2: chart.scales.y2 ? {
                                            min: chart.scales.y2.min,
                                            max: chart.scales.y2.max
                                        } : undefined,
                                        y3: chart.scales.y3 ? {
                                            min: chart.scales.y3.min,
                                            max: chart.scales.y3.max
                                        } : undefined,
                                        y4: chart.scales.y4 ? {
                                            min: chart.scales.y4.min,
                                            max: chart.scales.y4.max
                                        } : undefined
                                    };
                                    preserveZoom = true;
                                }
                            },
                            limits: {
                                x: {min: 'original', max: 'original'},
                                y: {min: 'original', max: 'original'}
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            display: true,
                            min: savedZoomState && preserveZoom ? savedZoomState.x.min : undefined,
                            max: savedZoomState && preserveZoom ? savedZoomState.x.max : undefined,
                            title: {
                                display: false
                            },
                            ticks: {
                                display: true
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        y: {
                            display: true,
                            position: 'left',
                            min: savedZoomState && preserveZoom ? savedZoomState.y.min : undefined,
                            max: savedZoomState && preserveZoom ? savedZoomState.y.max : undefined,
                            title: {
                                display: false
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        y2: {
                            display: usedAxes.has('y2'),
                            position: 'right',
                            min: savedZoomState && preserveZoom && savedZoomState.y2 ? savedZoomState.y2.min : undefined,
                            max: savedZoomState && preserveZoom && savedZoomState.y2 ? savedZoomState.y2.max : undefined,
                            title: {
                                display: false
                            },
                            grid: {
                                display: false
                            }
                        },
                        y3: {
                            display: usedAxes.has('y3'),
                            position: 'right',
                            min: savedZoomState && preserveZoom && savedZoomState.y3 ? savedZoomState.y3.min : undefined,
                            max: savedZoomState && preserveZoom && savedZoomState.y3 ? savedZoomState.y3.max : undefined,
                            title: {
                                display: false
                            },
                            grid: {
                                display: false
                            }
                        },
                        y4: {
                            display: usedAxes.has('y4'),
                            position: 'right',
                            min: savedZoomState && preserveZoom && savedZoomState.y4 ? savedZoomState.y4.min : undefined,
                            max: savedZoomState && preserveZoom && savedZoomState.y4 ? savedZoomState.y4.max : undefined,
                            title: {
                                display: false
                            },
                            grid: {
                                display: false
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });

            // limitsを手動で更新（データの全体範囲+マージンに設定、各軸ごと）
            if (chart.options.plugins.zoom.limits) {
                const xMargin = (maxX - minX) * 0.1; // x軸の範囲の10%をマージン
                chart.options.plugins.zoom.limits.x = {min: minX - xMargin, max: maxX + xMargin};

                // 第1軸（y）
                if (minY !== Infinity && maxY !== -Infinity) {
                    const yMargin = (maxY - minY) * 0.1;
                    chart.options.plugins.zoom.limits.y = {min: minY - yMargin, max: maxY + yMargin};
                }

                // 第2軸（y2）
                if (minY2 !== Infinity && maxY2 !== -Infinity) {
                    const y2Margin = (maxY2 - minY2) * 0.1;
                    chart.options.plugins.zoom.limits.y2 = {min: minY2 - y2Margin, max: maxY2 + y2Margin};
                }

                // 第3軸（y3）
                if (minY3 !== Infinity && maxY3 !== -Infinity) {
                    const y3Margin = (maxY3 - minY3) * 0.1;
                    chart.options.plugins.zoom.limits.y3 = {min: minY3 - y3Margin, max: maxY3 + y3Margin};
                }

                // 第4軸（y4）
                if (minY4 !== Infinity && maxY4 !== -Infinity) {
                    const y4Margin = (maxY4 - minY4) * 0.1;
                    chart.options.plugins.zoom.limits.y4 = {min: minY4 - y4Margin, max: maxY4 + y4Margin};
                }
            }

            // 表示・非表示状態を復元
            if (datasetVisibility.size > 0) {
                chart.data.datasets.forEach((dataset, index) => {
                    if (datasetVisibility.has(dataset.label)) {
                        const isVisible = datasetVisibility.get(dataset.label);
                        const meta = chart.getDatasetMeta(index);
                        meta.hidden = !isVisible;
                    }
                });
                // スケールはチャート作成時に固定されているので、updateしても範囲は変わらない
                chart.update('none');
            }

            // 次回以降はズームを保持する
            preserveZoom = true;

            // ズームリセットボタンとCSV出力ボタンを表示
            resetZoomBtn.style.display = 'inline-block';
            exportCsvBtn.style.display = 'inline-block';

            // 既存の点滅タイマーをクリア
            if (blinkTimer) {
                clearInterval(blinkTimer);
            }

            // 閾値違反がある場合は点滅を開始
            const violationIndices = [];
            chart.data.datasets.forEach((dataset, index) => {
                if (dataset.isViolation) {
                    violationIndices.push(index);
                }
            });

            if (violationIndices.length > 0) {
                blinkTimer = setInterval(() => {
                    blinkState = !blinkState;
                    violationIndices.forEach(index => {
                        const dataset = chart.data.datasets[index];
                        if (blinkState) {
                            dataset.borderColor = 'rgb(255, 0, 0)';
                        } else {
                            dataset.borderColor = 'rgba(255, 0, 0, 0.2)';
                        }
                    });
                    chart.update('none'); // アニメーションなしで更新
                }, 1200); // 1200msごとに点滅（負荷軽減）
            }
        }

        // ズーム状態を保存する関数（共通化）
        function saveCurrentZoomState() {
            savedZoomState = {
                x: {
                    min: chart.scales.x.min,
                    max: chart.scales.x.max
                },
                y: {
                    min: chart.scales.y.min,
                    max: chart.scales.y.max
                },
                y2: chart.scales.y2 ? {
                    min: chart.scales.y2.min,
                    max: chart.scales.y2.max
                } : undefined,
                y3: chart.scales.y3 ? {
                    min: chart.scales.y3.min,
                    max: chart.scales.y3.max
                } : undefined,
                y4: chart.scales.y4 ? {
                    min: chart.scales.y4.min,
                    max: chart.scales.y4.max
                } : undefined
            };
            preserveZoom = true;
        }

        // 軸を移動する汎用関数
        function panAxis(axis, delta) {
            if (!chart || !chart.scales[axis]) return;

            const scale = chart.scales[axis];
            const currentRange = scale.max - scale.min;
            const chartArea = chart.chartArea;

            // 軸に応じた幅または高さを取得
            const dimension = axis === 'x'
                ? chartArea.right - chartArea.left
                : chartArea.bottom - chartArea.top;

            const pixelPerUnit = dimension / currentRange;
            const deltaInPixels = delta * pixelPerUnit;

            // Chart.jsのpanメソッドを使用
            const panConfig = {};
            panConfig[axis] = deltaInPixels;
            chart.pan(panConfig, undefined, 'none');

            // ズーム状態を保存
            saveCurrentZoomState();
        }

        // キーボードの矢印キーでx軸を移動する関数
        function panXAxis(delta) {
            panAxis('x', delta);
        }

        // キーボードの矢印キーでy軸を移動する関数
        function panYAxis(delta) {
            panAxis('y', delta);
        }

        // キーの押下状態を追跡
        const keysPressed = {
            ArrowRight: false,
            ArrowLeft: false,
            ArrowUp: false,
            ArrowDown: false
        };

        let animationFrameId = null;

        // 連続移動を実行する関数
        function continuousPan() {
            if (!chart) return;

            if (keysPressed.ArrowRight) {
                panXAxis(-1); // 右に移動（x軸-1、左方向にパン）
            }
            if (keysPressed.ArrowLeft) {
                panXAxis(1); // 左に移動（x軸+1、右方向にパン）
            }
            if (keysPressed.ArrowUp) {
                panYAxis(0.05); // 上に移動（y軸+0.05、上方向にパン）
            }
            if (keysPressed.ArrowDown) {
                panYAxis(-0.05); // 下に移動（y軸-0.05、下方向にパン）
            }

            // いずれかのキーが押されている場合は継続
            if (keysPressed.ArrowRight || keysPressed.ArrowLeft ||
                keysPressed.ArrowUp || keysPressed.ArrowDown) {
                animationFrameId = requestAnimationFrame(continuousPan);
            }
        }

        // キーボードイベントリスナーを追加
        document.addEventListener('keydown', (e) => {
            if (!chart) return; // グラフが存在しない場合は何もしない

            if (e.key === 'ArrowRight' || e.key === 'ArrowLeft' ||
                e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault(); // デフォルトのスクロール動作を防止

                // まだ押されていない場合のみ開始
                if (!keysPressed[e.key]) {
                    keysPressed[e.key] = true;

                    // 最初のキーが押された時にアニメーションを開始
                    if (!animationFrameId) {
                        continuousPan();
                    }
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowRight' || e.key === 'ArrowLeft' ||
                e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                keysPressed[e.key] = false;

                // すべてのキーが離された場合はアニメーションを停止
                if (!keysPressed.ArrowRight && !keysPressed.ArrowLeft &&
                    !keysPressed.ArrowUp && !keysPressed.ArrowDown) {
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                }
            }
        });

        // グラフデータをCSVファイルとして出力する関数
        function exportChartDataToCsv() {
            if (!chart || !chart.data.datasets || chart.data.datasets.length === 0) {
                alert('出力するデータがありません');
                return;
            }

            const datasets = chart.data.datasets;

            // ズームされている範囲を取得
            const xScale = chart.scales.x;
            const minX = Math.floor(xScale.min);
            const maxX = Math.ceil(xScale.max);

            // 全データセットから表示範囲内のX座標を収集
            const xValues = new Set();
            datasets.forEach(dataset => {
                if (dataset.data && Array.isArray(dataset.data)) {
                    dataset.data.forEach(point => {
                        if (point && typeof point === 'object' && point.x >= minX && point.x <= maxX) {
                            xValues.add(point.x);
                        }
                    });
                }
            });

            // X座標をソート
            const sortedX = Array.from(xValues).sort((a, b) => a - b);

            if (sortedX.length === 0) {
                alert('表示範囲内にデータがありません');
                return;
            }

            // CSVヘッダーを作成
            let csvContent = 'index';
            datasets.forEach(dataset => {
                // ラベルから列名部分のみを取得（"ファイル名 - 列名" から "列名" を抽出）
                const columnName = dataset.label.split(' - ')[1] || dataset.label;
                csvContent += ',' + columnName;
            });
            csvContent += '\n';

            // データ行を作成（表示範囲のみ）
            sortedX.forEach(x => {
                csvContent += x;
                datasets.forEach(dataset => {
                    const point = dataset.data.find(p => p && p.x === x);
                    const value = point ? point.y : '';
                    csvContent += ',' + value;
                });
                csvContent += '\n';
            });

            // CSVファイルをダウンロード
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            // 現在の日時でファイル名を生成
            const now = new Date();
            const timestamp = now.getFullYear() +
                String(now.getMonth() + 1).padStart(2, '0') +
                String(now.getDate()).padStart(2, '0') + '_' +
                String(now.getHours()).padStart(2, '0') +
                String(now.getMinutes()).padStart(2, '0') +
                String(now.getSeconds()).padStart(2, '0');
            const filename = `graph_data_${timestamp}.csv`;

            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    </script>
</body>
</html>
