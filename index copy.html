<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>折れ線グラフツクール君1号</title>
    <script src="libs/chart.umd.js"></script>
    <script src="libs/hammer.min.js"></script>
    <script src="libs/chartjs-plugin-zoom.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #a8dadc 0%, #d4f1f4 100%);
            min-height: 100vh;
            padding: 15px;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 0 10px;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
            margin-bottom: 15px;
        }

        .header-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        h1 {
            color: #333;
            margin: 0;
            font-size: 24px;
        }

        .header-buttons {
            display: flex;
            gap: 10px;
        }

        .header-buttons input[type="file"] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: inline-block;
            padding: 12px 24px;
            background: linear-gradient(135deg, #4da8da 0%, #73c5e3 100%);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(77, 168, 218, 0.4);
        }

        .chart-container {
            position: relative;
            height: 600px;
            margin-top: 20px;
        }

        .file-input-wrapper {
            position: relative;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            margin-bottom: 20px;
        }

        .controls-container {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px 15px;
            border: 2px solid #4da8da;
            border-radius: 8px;
            background: #f0f8ff;
        }

        .legend-threshold-wrapper {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .legend-checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .legend-label {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            cursor: pointer;
            white-space: nowrap;
        }

        .offset-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .offset-label-text {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            white-space: nowrap;
        }

        .file-list-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: flex-start;
            max-width: 300px;
        }

        .file-item-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            flex-basis: calc(33.333% - 7px);
            min-width: 80px;
        }

        .file-name {
            font-size: 12px;
            color: #333;
            font-weight: 500;
            white-space: nowrap;
        }

        .offset-input {
            width: 80px;
            padding: 6px 10px;
            border: 2px solid #4da8da;
            border-radius: 6px;
            font-size: 14px;
            text-align: center;
        }

        .offset-input:focus {
            outline: none;
            border-color: #2c8bb8;
        }

        .y-axis-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-start;
        }

        .y-axis-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .y-axis-label {
            font-size: 12px;
            font-weight: 500;
            min-width: 30px;
        }

        .y-axis-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .y-axis-checkbox-label {
            font-size: 12px;
            font-weight: 500;
            color: #333;
            cursor: pointer;
            white-space: nowrap;
        }

        .y-axis-select {
            padding: 4px 8px;
            border: 2px solid #4da8da;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            background-color: white;
            cursor: pointer;
        }

        .y-axis-select:focus {
            outline: none;
            border-color: #2c8bb8;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="header-wrapper">
                <h1>折れ線グラフツクール君1号</h1>
                <div class="header-buttons">
                    <input type="file" id="csvInput" multiple accept=".csv">
                    <label for="csvInput" class="file-input-label">
                        CSVファイルを選択（複数可）
                    </label>
                    <button id="resetZoomBtn" class="file-input-label" style="display: none;">
                        ズームリセット
                    </button>
                    <button id="exportCsvBtn" class="file-input-label" style="display: none;">
                        CSV出力
                    </button>
                </div>
            </div>
            <div class="file-input-wrapper">
                <div class="controls-container" style="display: none;" id="controlsContainer">
                    <div class="legend-threshold-wrapper">
                        <div class="legend-checkbox-wrapper">
                            <input type="checkbox" id="legendCheckbox" class="legend-checkbox">
                            <label for="legendCheckbox" class="legend-label">凡例</label>
                        </div>
                        <div id="thresholdSection" class="offset-section">
                            <span class="offset-label-text">閾値:</span>
                            <div style="display: flex; flex-direction: column; gap: 5px;">
                                <div style="display: flex; align-items: center; gap: 5px;">
                                    <span style="font-size: 12px; font-weight: 500; min-width: 40px;">上限:</span>
                                    <input type="number" id="upperThreshold" class="offset-input" placeholder="上限" style="width: 100px;">
                                </div>
                                <div style="display: flex; align-items: center; gap: 5px;">
                                    <span style="font-size: 12px; font-weight: 500; min-width: 40px;">下限:</span>
                                    <input type="number" id="lowerThreshold" class="offset-input" placeholder="下限" style="width: 100px;">
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="offsetSection" class="offset-section">
                        <span class="offset-label-text">オフセット:</span>
                        <div id="fileListContainer" class="file-list-container">
                            <!-- ファイルリストと位置補正入力欄がここに動的に追加されます -->
                        </div>
                    </div>
                    <div class="offset-section">
                        <span class="offset-label-text">X軸:</span>
                        <select id="xAxisSelect" class="y-axis-select" style="width: 120px;">
                            <option value="">なし</option>
                        </select>
                    </div>
                    <div class="offset-section">
                        <span class="offset-label-text">除外:</span>
                        <div id="excludeContainer" style="display: flex; flex-wrap: wrap; gap: 5px; max-width: 300px; max-height: 80px; overflow-y: auto; border: 1px solid #ddd; padding: 5px; border-radius: 4px;">
                            <!-- チェックボックスがここに動的に追加されます -->
                        </div>
                    </div>
                    <div id="yAxisSection" class="offset-section">
                        <span class="offset-label-text">第2軸:</span>
                        <div class="y-axis-section">
                            <div class="y-axis-item">
                                <select id="yAxis1Select" class="y-axis-select">
                                    <option value="y2">第2軸</option>
                                    <option value="y3">第3軸</option>
                                    <option value="y4">第4軸</option>
                                </select>
                                <input type="checkbox" id="yAxis1Check" class="y-axis-checkbox">
                                <label for="yAxis1Check" class="y-axis-checkbox-label">含む</label>
                                <input type="text" id="yAxis1Input" class="offset-input" placeholder="列名の文字列" style="width: 120px;">
                            </div>
                            <div class="y-axis-item">
                                <select id="yAxis2Select" class="y-axis-select">
                                    <option value="y2">第2軸</option>
                                    <option value="y3">第3軸</option>
                                    <option value="y4">第4軸</option>
                                </select>
                                <input type="checkbox" id="yAxis2Check" class="y-axis-checkbox">
                                <label for="yAxis2Check" class="y-axis-checkbox-label">含む</label>
                                <input type="text" id="yAxis2Input" class="offset-input" placeholder="列名の文字列" style="width: 120px;">
                            </div>
                            <div class="y-axis-item">
                                <select id="yAxis3Select" class="y-axis-select">
                                    <option value="y2">第2軸</option>
                                    <option value="y3">第3軸</option>
                                    <option value="y4">第4軸</option>
                                </select>
                                <input type="checkbox" id="yAxis3Check" class="y-axis-checkbox">
                                <label for="yAxis3Check" class="y-axis-checkbox-label">含む</label>
                                <input type="text" id="yAxis3Input" class="offset-input" placeholder="列名の文字列" style="width: 120px;">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="chart-container">
                <canvas id="myChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        const colors = [
            'rgb(255, 99, 132)',
            'rgb(54, 162, 235)',
            'rgb(75, 192, 192)',
            'rgb(255, 205, 86)',
            'rgb(153, 102, 255)',
            'rgb(255, 159, 64)',
            'rgb(199, 199, 199)',
            'rgb(83, 102, 255)',
            'rgb(255, 99, 255)',
            'rgb(99, 255, 132)'
        ];

        let chart = null;
        let uploadedFiles = [];
        let fileOffsets = new Map(); // ファイル名 -> オフセット値
        let preserveZoom = false; // ズーム状態を保持するかどうかのフラグ
        let savedZoomState = null; // 保存されたズーム状態
        let upperThresholdValue = null; // 上限閾値
        let lowerThresholdValue = null; // 下限閾値
        let blinkTimer = null; // 点滅タイマー
        let blinkState = true; // 点滅状態
        let datasetVisibility = new Map(); // データセットのラベル -> 表示状態のマップ
        let tooltipEnabled = false; // ツールチップの有効/無効状態（デフォルト: 非表示）
        let xAxisPattern = ''; // X軸として使用する列名のパターン
        let excludedColumns = []; // 除外する列名のリスト

        // 第2軸設定
        let yAxisConfigs = [
            { enabled: false, pattern: '', axis: 'y2' },  // 設定1（デフォルト: 第2軸）
            { enabled: false, pattern: '', axis: 'y2' },  // 設定2（デフォルト: 第2軸）
            { enabled: false, pattern: '', axis: 'y2' }   // 設定3（デフォルト: 第2軸）
        ];

        const csvInput = document.getElementById('csvInput');
        const resetZoomBtn = document.getElementById('resetZoomBtn');
        const exportCsvBtn = document.getElementById('exportCsvBtn');
        const fileListContainer = document.getElementById('fileListContainer');
        const controlsContainer = document.getElementById('controlsContainer');
        const legendCheckbox = document.getElementById('legendCheckbox');
        const xAxisSelect = document.getElementById('xAxisSelect');
        const excludeContainer = document.getElementById('excludeContainer');
        const upperThresholdInput = document.getElementById('upperThreshold');
        const lowerThresholdInput = document.getElementById('lowerThreshold');

        // 第2軸入力要素
        const yAxis1Select = document.getElementById('yAxis1Select');
        const yAxis1Check = document.getElementById('yAxis1Check');
        const yAxis1Input = document.getElementById('yAxis1Input');
        const yAxis2Select = document.getElementById('yAxis2Select');
        const yAxis2Check = document.getElementById('yAxis2Check');
        const yAxis2Input = document.getElementById('yAxis2Input');
        const yAxis3Select = document.getElementById('yAxis3Select');
        const yAxis3Check = document.getElementById('yAxis3Check');
        const yAxis3Input = document.getElementById('yAxis3Input');

        resetZoomBtn.addEventListener('click', () => {
            if (chart) {
                chart.resetZoom();
                savedZoomState = null; // ズーム状態をクリア
                preserveZoom = false; // リセット後は保存しない
            }
        });

        // 凡例チェックボックスのイベントリスナー
        legendCheckbox.addEventListener('change', async (e) => {
            tooltipEnabled = e.target.checked; // チェックON = ツールチップON
            if (chart) {
                preserveZoom = true;
                await renderChartFromFiles();
            }
        });

        // X軸設定のイベントリスナー
        xAxisSelect.addEventListener('change', async (e) => {
            xAxisPattern = e.target.value;
            if (chart) {
                preserveZoom = true;
                await renderChartFromFiles();
            }
        });

        exportCsvBtn.addEventListener('click', () => {
            if (chart) {
                exportChartDataToCsv();
            }
        });

        // 閾値の入力イベント
        upperThresholdInput.addEventListener('input', async (e) => {
            const value = e.target.value;
            upperThresholdValue = value === '' ? null : parseFloat(value);
            if (chart) {
                preserveZoom = true; // 閾値変更時はズームを保持
                await renderChartFromFiles();
            }
        });

        lowerThresholdInput.addEventListener('input', async (e) => {
            const value = e.target.value;
            lowerThresholdValue = value === '' ? null : parseFloat(value);
            if (chart) {
                preserveZoom = true; // 閾値変更時はズームを保持
                await renderChartFromFiles();
            }
        });

        // 第2軸設定のイベントリスナー
        yAxis1Select.addEventListener('change', async (e) => {
            yAxisConfigs[0].axis = e.target.value;
            if (chart && yAxisConfigs[0].enabled) {
                preserveZoom = true;
                await renderChartFromFiles();
            }
        });

        yAxis1Check.addEventListener('change', async (e) => {
            yAxisConfigs[0].enabled = e.target.checked;
            if (chart) {
                preserveZoom = true;
                await renderChartFromFiles();
            }
        });

        yAxis1Input.addEventListener('input', async (e) => {
            yAxisConfigs[0].pattern = e.target.value.trim();
            if (chart && yAxisConfigs[0].enabled) {
                preserveZoom = true;
                await renderChartFromFiles();
            }
        });

        yAxis2Select.addEventListener('change', async (e) => {
            yAxisConfigs[1].axis = e.target.value;
            if (chart && yAxisConfigs[1].enabled) {
                preserveZoom = true;
                await renderChartFromFiles();
            }
        });

        yAxis2Check.addEventListener('change', async (e) => {
            yAxisConfigs[1].enabled = e.target.checked;
            if (chart) {
                preserveZoom = true;
                await renderChartFromFiles();
            }
        });

        yAxis2Input.addEventListener('input', async (e) => {
            yAxisConfigs[1].pattern = e.target.value.trim();
            if (chart && yAxisConfigs[1].enabled) {
                preserveZoom = true;
                await renderChartFromFiles();
            }
        });

        yAxis3Select.addEventListener('change', async (e) => {
            yAxisConfigs[2].axis = e.target.value;
            if (chart && yAxisConfigs[2].enabled) {
                preserveZoom = true;
                await renderChartFromFiles();
            }
        });

        yAxis3Check.addEventListener('change', async (e) => {
            yAxisConfigs[2].enabled = e.target.checked;
            if (chart) {
                preserveZoom = true;
                await renderChartFromFiles();
            }
        });

        yAxis3Input.addEventListener('input', async (e) => {
            yAxisConfigs[2].pattern = e.target.value.trim();
            if (chart && yAxisConfigs[2].enabled) {
                preserveZoom = true;
                await renderChartFromFiles();
            }
        });

        csvInput.addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);

            if (files.length === 0) return;

            uploadedFiles = files;

            // ファイルごとのオフセットを初期化
            fileOffsets.clear();
            files.forEach(file => fileOffsets.set(file.name, 0));

            // ファイルリストを表示
            displayFileList(files);

            // 新しいファイルアップロード時はズームと表示状態をリセット
            preserveZoom = false;
            savedZoomState = null;
            datasetVisibility.clear();

            // グラフを描画
            await renderChartFromFiles();
        });

        // ファイルリストを表示する関数
        function displayFileList(files) {
            fileListContainer.innerHTML = '';

            files.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item-control';

                const fileName = document.createElement('span');
                fileName.className = 'file-name';
                fileName.textContent = file.name;

                const offsetInput = document.createElement('input');
                offsetInput.type = 'number';
                offsetInput.className = 'offset-input';
                offsetInput.value = '0';
                offsetInput.step = '1';
                offsetInput.placeholder = '位置補正';
                offsetInput.dataset.fileName = file.name;

                offsetInput.addEventListener('input', async (e) => {
                    const offset = parseInt(e.target.value) || 0;
                    fileOffsets.set(file.name, offset);
                    preserveZoom = true; // オフセット変更時もズームと表示状態を保持
                    await renderChartFromFiles();
                });

                fileItem.appendChild(fileName);
                fileItem.appendChild(offsetInput);

                fileListContainer.appendChild(fileItem);
            });

            // コントロールコンテナを表示
            controlsContainer.style.display = 'flex';
        }

        // ファイルからグラフを描画する関数
        async function renderChartFromFiles() {
            const parsedData = [];
            let minIndex = 0;
            let maxIndex = 0;

            // すべてのファイルを解析してインデックス範囲を計算
            for (let i = 0; i < uploadedFiles.length; i++) {
                const file = uploadedFiles[i];
                try {
                    const text = await file.text();
                    const offset = fileOffsets.get(file.name) || 0;
                    const result = parseCSV(text, file.name.replace('.csv', ''), offset);
                    parsedData.push(result);

                    // インデックスの範囲を更新
                    if (result.minIndex < minIndex) minIndex = result.minIndex;
                    if (result.maxIndex > maxIndex) maxIndex = result.maxIndex;
                } catch (error) {
                    console.error(`Error parsing ${file.name}:`, error);
                    alert(`${file.name}の読み込みに失敗しました: ${error.message}`);
                }
            }

            // X軸selectの選択肢を更新
            const columnNames = new Set();
            parsedData.forEach(fileData => {
                fileData.datasets.forEach(dataset => {
                    const columnName = dataset.label.split(' - ')[1];
                    if (columnName) {
                        columnNames.add(columnName);
                    }
                });
            });

            // 現在の選択値を保存
            const currentXAxisValue = xAxisSelect.value;

            // selectをクリアして再構築
            xAxisSelect.innerHTML = '<option value="">なし</option>';
            Array.from(columnNames).sort().forEach(columnName => {
                const option = document.createElement('option');
                option.value = columnName;
                option.textContent = columnName;
                xAxisSelect.appendChild(option);
            });

            // 前の選択値を復元（存在する場合）
            if (currentXAxisValue && columnNames.has(currentXAxisValue)) {
                xAxisSelect.value = currentXAxisValue;
            }

            // 除外チェックボックスを更新
            const currentExcludedValues = excludedColumns.slice();

            // コンテナをクリアして再構築
            excludeContainer.innerHTML = '';
            Array.from(columnNames).sort().forEach(columnName => {
                const label = document.createElement('label');
                label.style.display = 'flex';
                label.style.alignItems = 'center';
                label.style.gap = '3px';
                label.style.cursor = 'pointer';
                label.style.whiteSpace = 'nowrap';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = columnName;
                checkbox.checked = currentExcludedValues.includes(columnName);

                checkbox.addEventListener('change', async (e) => {
                    if (e.target.checked) {
                        if (!excludedColumns.includes(columnName)) {
                            excludedColumns.push(columnName);
                        }
                    } else {
                        const index = excludedColumns.indexOf(columnName);
                        if (index > -1) {
                            excludedColumns.splice(index, 1);
                        }
                    }
                    if (chart) {
                        preserveZoom = true;
                        await renderChartFromFiles();
                    }
                });

                const span = document.createElement('span');
                span.textContent = columnName;
                span.style.fontSize = '12px';

                label.appendChild(checkbox);
                label.appendChild(span);
                excludeContainer.appendChild(label);
            });

            // データセットを再構築
            const datasets = [];
            const thresholdViolations = []; // 閾値違反のデータを保存
            let colorIndex = 0;

            parsedData.forEach(fileData => {
                // X軸データを探す
                let xAxisData = null;
                if (xAxisPattern) {
                    const xAxisDataset = fileData.datasets.find(dataset => {
                        const columnName = dataset.label.split(' - ')[1] || '';
                        return columnName === xAxisPattern;
                    });
                    if (xAxisDataset) {
                        // X軸データのマップを作成（行インデックス -> X値）
                        xAxisData = new Map();
                        xAxisDataset.data.forEach(point => {
                            xAxisData.set(point.x, point.y);
                        });
                    }
                }

                fileData.datasets.forEach(dataset => {
                    const columnName = dataset.label.split(' - ')[1] || '';

                    // X軸として使用する列はスキップ
                    if (xAxisPattern && columnName === xAxisPattern) {
                        return;
                    }

                    // 除外された列はスキップ
                    if (excludedColumns.includes(columnName)) {
                        return;
                    }

                    let numericData;
                    if (xAxisData) {
                        // X軸データがある場合、それを使用
                        numericData = dataset.data.map(point => ({
                            x: xAxisData.get(point.x) || parseInt(point.x),
                            y: point.y
                        }));
                    } else {
                        // X軸データがない場合、従来通りインデックスを使用
                        numericData = dataset.data.map(point => ({
                            x: parseInt(point.x),
                            y: point.y
                        }));
                    }

                    // 第2軸の判定
                    const yAxisID = getYAxisID(dataset.label, fileData.fileName);

                    datasets.push({
                        label: dataset.label,
                        data: numericData,
                        borderColor: colors[colorIndex % colors.length],
                        backgroundColor: colors[colorIndex % colors.length].replace('rgb', 'rgba').replace(')', ', 0.1)'),
                        tension: 0,
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        fill: false,
                        spanGaps: true,
                        yAxisID: yAxisID
                    });

                    // 閾値を超えた部分を検出
                    if (upperThresholdValue !== null || lowerThresholdValue !== null) {
                        const violationData = numericData.filter(point => {
                            const exceedsUpper = upperThresholdValue !== null && point.y > upperThresholdValue;
                            const exceedsLower = lowerThresholdValue !== null && point.y < lowerThresholdValue;
                            return exceedsUpper || exceedsLower;
                        });

                        // 違反データがあれば保存（線として表示）
                        if (violationData.length > 0) {
                            thresholdViolations.push({
                                label: dataset.label + ' (閾値超過)',
                                data: violationData,
                                originalColor: colors[colorIndex % colors.length],
                                yAxisID: yAxisID
                            });
                        }
                    }

                    colorIndex++;
                });
            });

            // 閾値の線を追加
            if (upperThresholdValue !== null) {
                datasets.push({
                    label: '上限閾値',
                    data: [
                        { x: minIndex, y: upperThresholdValue },
                        { x: maxIndex, y: upperThresholdValue }
                    ],
                    borderColor: 'rgb(255, 0, 0)',
                    backgroundColor: 'rgba(255, 0, 0, 0.1)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    fill: false,
                    tension: 0,
                    yAxisID: 'y'
                });
            }

            if (lowerThresholdValue !== null) {
                datasets.push({
                    label: '下限閾値',
                    data: [
                        { x: minIndex, y: lowerThresholdValue },
                        { x: maxIndex, y: lowerThresholdValue }
                    ],
                    borderColor: 'rgb(255, 0, 0)',
                    backgroundColor: 'rgba(255, 0, 0, 0.1)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    fill: false,
                    tension: 0,
                    yAxisID: 'y'
                });
            }

            // 閾値違反の線を追加（点滅用）
            thresholdViolations.forEach(violation => {
                datasets.push({
                    label: violation.label,
                    data: violation.data,
                    borderColor: 'rgb(255, 0, 0)',
                    backgroundColor: 'rgba(255, 0, 0, 0.1)',
                    tension: 0,
                    borderWidth: 3,
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    fill: false,
                    spanGaps: false, // 閾値を超えていない部分は線を引かない
                    isViolation: true, // 点滅対象のマーク
                    yAxisID: violation.yAxisID
                });
            });

            if (datasets.length > 0) {
                renderChart(datasets);
            }
        }

        function parseCSV(text, fileName, offset = 0) {
            const lines = text.trim().split('\n');
            if (lines.length < 2) {
                throw new Error('CSVファイルが空か、データが不足しています');
            }

            // ヘッダー行を解析
            const headers = lines[0].split(',').map(h => h.trim());
            const columnCount = headers.length;

            if (columnCount < 1) {
                throw new Error('CSVファイルには少なくとも1列が必要です');
            }

            // 各列のデータを格納する配列を初期化（すべての列をデータとして使用）
            const datasets = [];
            for (let col = 0; col < columnCount; col++) {
                datasets.push({
                    label: `${fileName} - ${headers[col]}`,
                    data: []
                });
            }

            // データの範囲を計算
            const dataRowCount = lines.length - 1; // ヘッダーを除く
            const minIndex = offset;
            const maxIndex = offset + dataRowCount - 1;

            // データ行を解析
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const values = line.split(',');
                if (values.length >= 1) {
                    // データ行のインデックス（0始まり）にオフセットを加える
                    const dataIndex = i - 1; // 0始まりのデータ行インデックス
                    const xValue = (dataIndex + offset).toString();

                    // すべての列を処理
                    for (let col = 0; col < Math.min(values.length, columnCount); col++) {
                        const yValue = parseFloat(values[col].trim());
                        if (!isNaN(yValue)) {
                            datasets[col].data.push({ x: xValue, y: yValue });
                        }
                    }
                }
            }

            return { datasets, minIndex, maxIndex, fileName };
        }

        // 第2軸IDを取得する関数
        function getYAxisID(label, fileName) {
            // ラベルから列名を抽出 ("fileName - columnName" から列名部分)
            const columnName = label.split(' - ')[1] || '';

            // 各設定をチェック
            for (let i = 0; i < yAxisConfigs.length; i++) {
                const config = yAxisConfigs[i];
                // チェックボックスがONで、パターンが入力されている場合のみ
                if (config.enabled && config.pattern) {
                    // 列名に指定文字列が含まれるかチェック
                    if (columnName.includes(config.pattern)) {
                        return config.axis; // 選択された軸（y2, y3, y4）を返す
                    }
                }
            }
            return 'y'; // デフォルトは第1軸
        }

        function renderChart(datasets) {
            const ctx = document.getElementById('myChart').getContext('2d');

            // 既存のグラフから各データセットの表示・非表示状態を保存
            if (chart && preserveZoom) {
                chart.data.datasets.forEach((dataset, index) => {
                    const meta = chart.getDatasetMeta(index);
                    datasetVisibility.set(dataset.label, !meta.hidden);
                });
            }

            if (chart) {
                chart.destroy();
            }

            // 使用されている軸を判定
            const usedAxes = new Set();
            datasets.forEach(dataset => {
                if (dataset.yAxisID) {
                    usedAxes.add(dataset.yAxisID);
                }
            });

            chart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    resizeDelay: 100, // リサイズ時の更新遅延（ミリ秒）
                    animation: false, // アニメーション完全無効化
                    plugins: {
                        decimation: {
                            enabled: true,
                            algorithm: 'lttb', // Largest-Triangle-Three-Buckets アルゴリズム
                            samples: 500 // 表示時の最大サンプル数
                        },
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 15,
                                font: {
                                    size: 12
                                }
                            },
                            onClick: function(e, legendItem, legend) {
                                // デフォルトの動作を実行（データセットの表示/非表示を切り替え）
                                const index = legendItem.datasetIndex;
                                const ci = legend.chart;

                                if (ci.isDatasetVisible(index)) {
                                    ci.hide(index);
                                    legendItem.hidden = true;
                                } else {
                                    ci.show(index);
                                    legendItem.hidden = false;
                                }

                                // 表示/非表示切り替え後のズーム状態を保存
                                setTimeout(() => {
                                    // Chart.jsがスケールを再計算した後に実行
                                    if (ci.scales && ci.scales.x && ci.scales.y) {
                                        savedZoomState = {
                                            x: {
                                                min: ci.scales.x.min,
                                                max: ci.scales.x.max
                                            },
                                            y: {
                                                min: ci.scales.y.min,
                                                max: ci.scales.y.max
                                            },
                                            y2: ci.scales.y2 ? {
                                                min: ci.scales.y2.min,
                                                max: ci.scales.y2.max
                                            } : undefined,
                                            y3: ci.scales.y3 ? {
                                                min: ci.scales.y3.min,
                                                max: ci.scales.y3.max
                                            } : undefined,
                                            y4: ci.scales.y4 ? {
                                                min: ci.scales.y4.min,
                                                max: ci.scales.y4.max
                                            } : undefined
                                        };
                                        preserveZoom = true;
                                    }
                                }, 50);
                            }
                        },
                        tooltip: {
                            enabled: tooltipEnabled,
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            titleFont: {
                                size: 14
                            },
                            bodyFont: {
                                size: 13
                            },
                            callbacks: {
                                title: function() {
                                    return '';  // タイトル（行番号）を非表示
                                }
                            }
                        },
                        zoom: {
                            zoom: {
                                wheel: {
                                    enabled: true,
                                },
                                pinch: {
                                    enabled: true
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: 'rgba(102, 126, 234, 0.2)',
                                    borderColor: 'rgba(102, 126, 234, 0.8)',
                                    borderWidth: 1,
                                    threshold: 50,
                                },
                                mode: 'xy',
                                onZoomComplete: function({chart}) {
                                    // ズーム完了後に状態を保存
                                    savedZoomState = {
                                        x: {
                                            min: chart.scales.x.min,
                                            max: chart.scales.x.max
                                        },
                                        y: {
                                            min: chart.scales.y.min,
                                            max: chart.scales.y.max
                                        },
                                        y2: chart.scales.y2 ? {
                                            min: chart.scales.y2.min,
                                            max: chart.scales.y2.max
                                        } : undefined,
                                        y3: chart.scales.y3 ? {
                                            min: chart.scales.y3.min,
                                            max: chart.scales.y3.max
                                        } : undefined,
                                        y4: chart.scales.y4 ? {
                                            min: chart.scales.y4.min,
                                            max: chart.scales.y4.max
                                        } : undefined
                                    };
                                    preserveZoom = true;
                                }
                            },
                            pan: {
                                enabled: true,
                                mode: 'xy',
                                modifierKey: 'shift',
                                onPanComplete: function({chart}) {
                                    // パン完了後に状態を保存
                                    savedZoomState = {
                                        x: {
                                            min: chart.scales.x.min,
                                            max: chart.scales.x.max
                                        },
                                        y: {
                                            min: chart.scales.y.min,
                                            max: chart.scales.y.max
                                        },
                                        y2: chart.scales.y2 ? {
                                            min: chart.scales.y2.min,
                                            max: chart.scales.y2.max
                                        } : undefined,
                                        y3: chart.scales.y3 ? {
                                            min: chart.scales.y3.min,
                                            max: chart.scales.y3.max
                                        } : undefined,
                                        y4: chart.scales.y4 ? {
                                            min: chart.scales.y4.min,
                                            max: chart.scales.y4.max
                                        } : undefined
                                    };
                                    preserveZoom = true;
                                }
                            },
                            limits: {
                                x: {min: 'original', max: 'original'},
                                y: {min: 'original', max: 'original'}
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            display: true,
                            min: savedZoomState && preserveZoom ? savedZoomState.x.min : undefined,
                            max: savedZoomState && preserveZoom ? savedZoomState.x.max : undefined,
                            title: {
                                display: false
                            },
                            ticks: {
                                display: true
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        y: {
                            display: true,
                            position: 'left',
                            min: savedZoomState && preserveZoom ? savedZoomState.y.min : undefined,
                            max: savedZoomState && preserveZoom ? savedZoomState.y.max : undefined,
                            title: {
                                display: false
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        y2: {
                            display: usedAxes.has('y2'),
                            position: 'right',
                            min: savedZoomState && preserveZoom && savedZoomState.y2 ? savedZoomState.y2.min : undefined,
                            max: savedZoomState && preserveZoom && savedZoomState.y2 ? savedZoomState.y2.max : undefined,
                            title: {
                                display: false
                            },
                            grid: {
                                display: false
                            }
                        },
                        y3: {
                            display: usedAxes.has('y3'),
                            position: 'right',
                            min: savedZoomState && preserveZoom && savedZoomState.y3 ? savedZoomState.y3.min : undefined,
                            max: savedZoomState && preserveZoom && savedZoomState.y3 ? savedZoomState.y3.max : undefined,
                            title: {
                                display: false
                            },
                            grid: {
                                display: false
                            }
                        },
                        y4: {
                            display: usedAxes.has('y4'),
                            position: 'right',
                            min: savedZoomState && preserveZoom && savedZoomState.y4 ? savedZoomState.y4.min : undefined,
                            max: savedZoomState && preserveZoom && savedZoomState.y4 ? savedZoomState.y4.max : undefined,
                            title: {
                                display: false
                            },
                            grid: {
                                display: false
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });

            // 表示・非表示状態を復元
            if (datasetVisibility.size > 0) {
                chart.data.datasets.forEach((dataset, index) => {
                    if (datasetVisibility.has(dataset.label)) {
                        const isVisible = datasetVisibility.get(dataset.label);
                        const meta = chart.getDatasetMeta(index);
                        meta.hidden = !isVisible;
                    }
                });
                // スケールはチャート作成時に固定されているので、updateしても範囲は変わらない
                chart.update('none');
            }

            // 次回以降はズームを保持する
            preserveZoom = true;

            // ズームリセットボタンとCSV出力ボタンを表示
            resetZoomBtn.style.display = 'inline-block';
            exportCsvBtn.style.display = 'inline-block';

            // 既存の点滅タイマーをクリア
            if (blinkTimer) {
                clearInterval(blinkTimer);
            }

            // 閾値違反がある場合は点滅を開始
            const violationIndices = [];
            chart.data.datasets.forEach((dataset, index) => {
                if (dataset.isViolation) {
                    violationIndices.push(index);
                }
            });

            if (violationIndices.length > 0) {
                blinkTimer = setInterval(() => {
                    blinkState = !blinkState;
                    violationIndices.forEach(index => {
                        const dataset = chart.data.datasets[index];
                        if (blinkState) {
                            dataset.borderColor = 'rgb(255, 0, 0)';
                        } else {
                            dataset.borderColor = 'rgba(255, 0, 0, 0.2)';
                        }
                    });
                    chart.update('none'); // アニメーションなしで更新
                }, 800); // 800msごとに点滅（負荷軽減）
            }
        }

        // グラフデータをCSVファイルとして出力する関数
        function exportChartDataToCsv() {
            if (!chart || !chart.data.datasets || chart.data.datasets.length === 0) {
                alert('出力するデータがありません');
                return;
            }

            const datasets = chart.data.datasets;

            // ズームされている範囲を取得
            const xScale = chart.scales.x;
            const minX = Math.floor(xScale.min);
            const maxX = Math.ceil(xScale.max);

            // 全データセットから表示範囲内のX座標を収集
            const xValues = new Set();
            datasets.forEach(dataset => {
                if (dataset.data && Array.isArray(dataset.data)) {
                    dataset.data.forEach(point => {
                        if (point && typeof point === 'object' && point.x >= minX && point.x <= maxX) {
                            xValues.add(point.x);
                        }
                    });
                }
            });

            // X座標をソート
            const sortedX = Array.from(xValues).sort((a, b) => a - b);

            if (sortedX.length === 0) {
                alert('表示範囲内にデータがありません');
                return;
            }

            // CSVヘッダーを作成
            let csvContent = 'index';
            datasets.forEach(dataset => {
                csvContent += ',' + dataset.label;
            });
            csvContent += '\n';

            // データ行を作成（表示範囲のみ）
            sortedX.forEach(x => {
                csvContent += x;
                datasets.forEach(dataset => {
                    const point = dataset.data.find(p => p && p.x === x);
                    const value = point ? point.y : '';
                    csvContent += ',' + value;
                });
                csvContent += '\n';
            });

            // CSVファイルをダウンロード
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            // 現在の日時でファイル名を生成
            const now = new Date();
            const timestamp = now.getFullYear() +
                String(now.getMonth() + 1).padStart(2, '0') +
                String(now.getDate()).padStart(2, '0') + '_' +
                String(now.getHours()).padStart(2, '0') +
                String(now.getMinutes()).padStart(2, '0') +
                String(now.getSeconds()).padStart(2, '0');
            const filename = `graph_data_${timestamp}.csv`;

            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    </script>
</body>
</html>
